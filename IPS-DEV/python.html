<!DOCTYPE html>
<html>
  <head>
    <title>IPS-DEV</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="core/fonts/mono.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/animate.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/cinescript.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/style_core.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/mermaid.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/gitgraph.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/style_ensiie.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/katex.css"> 
  </head>
  <body>
    <textarea id="source" readonly>

layout: true
class: animated fadeIn middle numbers

.footnote[
`IPS-DEV` - N. Dubray - ENSIIE - 2024 - [:book:](../index.html)
]

---

# Python

.hcenter.w40[
![](images/python_logo.png)
]

.noflex[
.rightf.animated.middle.fadeInRight.wait1s.shadow.w20[![](images/guido_van_rossum.png)]

## Key points

* created by **Guido van Rossum** in 1989, first released in 1991
* name comes from the series **Monty Python's Flying Circus**
* **high-level**, **interpreted** programming language
* widely used by projects **of every size**
* emphasis on **code readability** and **powerful and concise syntax**
* supports **multiple programming paradigms** (object-oriented, imperative...)
* very large **standard library**
* reference implementation and interpreter: **`CPython`**
]

.block[
* `CPython` repository: [https://github.com/python/cpython](https://github.com/python/cpython)
* `Python` website: [https://www.python.org](https://www.python.org)
* `CPython` license: `PSFL` (Python Software Foundation License, compatible with the GPL)
]

---

# Python core philosophy

.noflex[
.rightf.animated.fadeInRight.wait1s.shadow.w25[![](images/tim_peters.png)]

## The Zen of Python, by Tim Peters (PEP 20)

1. Beautiful is better than ugly.
1. **Explicit is better than implicit.**
1. **Simple is better than complex.**
1. Complex is better than complicated.
1. Flat is better than nested.
1. Sparse is better than dense.
1. **Readability counts.**
1. **Special cases aren't special enough to break the rules.**
1. Although practicality beats purity.
1. **Errors should never pass silently.**
1. Unless explicitly silenced.
1. In the face of ambiguity, refuse the temptation to guess.
1. There should be one *and preferably only one* obvious way to do it.
1. Although that way may not be obvious at first unless you're Dutch.
1. Now is better than never.
1. Although never is often better than *right* now.
1. **If the implementation is hard to explain, it's a bad idea.**
1. If the implementation is easy to explain, it may be a good idea.
1. **Namespaces** are one honking great idea -- let's do more of those!
]

:arrow_right: Some examples of good Python style can be found [here](https://raw.githubusercontent.com/hblanks/zen-of-python-by-example/master/pep20_by_example.pdf).

---

# Table of content

## 1. Basic syntax of python

## 2. Function, classes, modules

## 3. Built-in python objects

---

# Python `helloworld`

## .hcenter[`[helloworld.py]`]
```python
#!/usr/bin/env python

# ^^ use '#!/usr/bin/env python3' for python3 scripts

# declare variables
a = 2
b = 8

# add two numbers
c = a + b # is it really that simple ?

# print some message
print("Hello from Python ! (c = %d)" % (c))
```

## .hcenter[Shell session]
```shell
$ chmod +x helloworld.py
$ ./helloworld.py
Hello from Python ! (c = 10)
```

.vspace[]

## Explanations

* Line 1: path to the Python interpreter
* Lines 3, 5, 9, 10, 12: text after `#` is a comment
* Lines 6, 7, 10: typing is dynamic
* Line 13: `%` allows some form of string formatting

---

# Python indentation

.alert.hcenter[
There is **no symbol** to delimitate blocks of code in `Python`.  
Blocks of code are defined using **indentation**.
]

.vspace[]

.numbers[

## Valid syntaxes

.row[
.column.w30[
```python
if True:
  print("Always")

```]
.column.w30[
```python
if True:
  print("Always")
else:
  print("Never")
```]
.column.w30[
```python
if True:
  print("Almost")
  print("Always")
else:
    print("Almost")
    print("Never")
```]
]

.vspace[]

## Invalid syntaxes

.row[
.column.w30[
```python
if True
  print("Always")
```]
.column.w30[
```python
if True:
  print("Almost")
    print("Always")
```]
.column.w30[
```python
if True:
    print("Almost")
    print("Always")
  else:

    print("Almost")
    print("Never")
```]
]
]

---

# Python identifiers

## Identifiers

* Identifiers name variables, functions, classes, modules, objects...
* They start with `[A-Za-z_]`, followed by zero or more `[A-Za-z0-9_]`.
* `Python` is **case-sensitive**.

## Reserved keywords

* `True False not and or          :` **Boolean algebra**
* `None is                        :` **Identity testing**
* `if elif else                   :` **Conditionals**
* `for while break continue pass  :` **Loops**
* `del                            :` ‚ö†Ô∏è Delete a name from the scope or...
* `global nonlocal                :` ‚ö†Ô∏è Global variables, name shadowing...
* `def class return               :` **Functions and Classes**
* `in                             :` **Container testing**
* `import from as                 :` **Module import**
* `with                           :` **Context managers**
* `try except raise finally       :` Error handling
* `yield                          :` Generator functions
* `assert                         :` Assertion/unit testing
* `lambda                         :` Lambda functions
* `async await                    :` Asynchronous programming [What color is your function](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)

---


# Naming conventions

## [PEP 8 ‚Äì Style Guide for Python Code](https://peps.python.org/pep-0008/)

```py
# Class names start with an **uppercase letter**
class MyClass:

  # Starting an identifier with _ indicates that the identifier is **protected**.
  _protected = 2

  # Starting an identifier with __ indicates that the identifier is **private**.
  __private = 4

  # If the identifier also ends with __ , the identifier is a **language-defined special name**.
  __dict__ = {}

# Everything else starts with a **lowercase letter**
myInstance = MyClass()

# Or
my_instance = MyClass()
```


---

# Functions

## A simple function

```python

# arg0: a **mandatory** argument
# arg1: an **optional** argument
def fun(arg0, arg1=6):
  c = arg0 + arg1
  return c

fun(2)              # Pass 1 (positional) argument
fun(2, 3)           # Pass 2 (positional) arguments
fun("abc", "def")   # They do not have to be doubles !
fun(arg1=3, arg0=2) # Here the arguments are **keyword** arguments, order does not matter
```

Python knows about the **argument names** - `help()` function

```
>>> help(fun)

Help on function fun in module __main__:

fun(arg0, arg1=6)
```

And it can also know about **the argument types** (type hints)

```py
>>> def fun(arg0: int, arg1: int = 6) -> int:
>>>   return 0
>>> help(fun)

fun(arg0: int, arg1: int = 6) -> int
```

---

# Functions

## Variable number of arguments `*args`

```py
def myprint(*args):
  for x in args:
    print(x)

myprint("some", "text", "to", "print")
```

‚û°Ô∏è `args` is a `list` of arguments

## Variable number of keyword arguments `**kwargs`

```py
def myprint(**kwargs):
  for name, symbol in kwargs.items():
    print(name, symbol)

myprint(hydrogen="H", helium="He")
```

‚û°Ô∏è `kwargs` is a `dict` of arguments

## You can use both

```py
def f(arg0, *args, **kwargs):
```

---

# Classes

```python
class MyClass:
  a = 3                            # static variable

  def __init__(self, b=None):      # "constructor"
    self.c = "toto"                # Initialize c member
    print(self.a)                  # print static variable
    print(b)                       # print function argument
    print(self.c)                  # print member of class
    d = self.myMethod(4, 4)        # call a method (inside a class)

  def myMethod(self, a, b = 2):    # instance method
    return self.a + a + b

  @staticmethod
  def myStaticMethod():            # static method
    return 'static method'

instance = MyClass(6)              # Instanciate a class
instance.x = 'new value'           # Set a member variable on the instance
instance.myMethod(4, 4)            # call a method of the object

print(MyClass.myStaticMethod())    # Call a static method
```

* Difference between a **class** and an **instance** of a class

```
>>> class A:
>>>   pass

>>> type(A)
<class 'type'>
>>> type(A())
<class '__main__.A'>
```

---

# How do i document my functions/classes ?

## Docstring

```python
def mySuperSum(a, b):
  """This function adds two objects"""
  return a + b

def mySuperProd(a, b):
  """This function multiplies two objects.

  Of course, a and b must allow a to be multiplied by b.
  Try this function with random input objects at your own risk.

  """
  return a * b
```

## Why ?

* The python function `help()` will print this documentation
* Some IDE can print this documentation if needed
* These docstrings can be automatically extracted ( :v: `doxygen` :v: )
* It is the standard way to document python code
* The python code can use this docstring
* Some tests and / or examples can be put in the docstrings `doctest`

## `help()` built-in

```python
help(mySuperSum) # in interactive mode
print(mySuperSum.__doc__)
```

---

# Modules

* A module is a collection of objects: classes, functions, variables, ...
* It is equivalent to a c++ namespace

* `import`: import the Module

```python
import math # import the "math" module

print(math.sqrt(2)) # 1.41421356237
```

* `as`: rename (alias) the module

```python
import math as m # import the "math" module and name it "m"

print(m.sqrt(2)) # 1.41421356237
```

* `from`: import specific objects from the module

```python
from math import sqrt # import only the "sqrt" function from the math module

print(sqrt(2)) # 1.41421356237
```

* ‚ö†Ô∏è the wildcard `*` allows to import everything from a module 

```python
from math import * # import everything from the math module

print(sqrt(2)) # 1.41421356237
```

This is as bad as `using namespace std;`

---

# Custom modules

* create a file containing functions, values, classes, etc...

## .hcenter[`[example.py]`]

```python
someval = 42 # a value

def func(a, b): # a function
  return a + b
```

* if `example.py` is in the current directory (`./example.py`):

```python
import example

print(example.func("Hello ", "world") # "Hello world"

print(example.someval) # 42
```

* if `example.py` is in a subdirectory (`./somedir/example.py`):

```python
import somedir

print(somedir.func("Hello ", "world") # "Hello world"

print(somedir.someval) # 42
```

---

# Module search path

* when looking for a module to import, python tries the following:
 1. search for a built-in module
 2. search directories from `sys.path`, in order

```python
import sys

print(sys.path)
# Output:
*# ['',
#  '/usr/bin', '/usr/lib64/python27.zip', '/usr/lib64/python2.7',
#  '/usr/lib64/python2.7/plat-linux2', '/usr/lib64/python2.7/lib-tk',
#  ...
*#  '.local/lib/python2.7/site-packages',
#  ...
#  '/usr/lib/python2.7/site-packages/IPython/Extensions',
*#  '/home/dubrayn/.ipython']
```


---

# The `dir()` built-in function

:arrow_right: list of valid attributes of an object

## .hcenter[`[example.py]`]

```python
someval = 42 # a value

def func(a, b): # a function
  return a + b
```

```python
import example

*print(dir(example))
# Output:
# ['__builtins__',
#  '__doc__',
#  '__file__',
#  '__name__',
#  '__package__',
#  'func',
#  'someval']
```

* without arguments, `dir()` returns a list of objects defined in the current scope

```python
*print(dir())
# Output:
# ['In', 'Out', '__', '_', '__IP', '___', '__builtins__', '__name__',
#  '_dh', '_i', '_i1', '_ih', '_ii', '_iii', '_ip', '_oh', '_sh', 'help' ]
```


---

# Built-in types

An üîí **immutable object** cannot be modified

## Numeric types

* üîí `bool              :` boolean type
* üîí `int float complex :` numeric types

## Sequence types: lists of objects

* ‚úèÔ∏è `list              :` an ordered list of objects
* üîí `tuple             :` an immutable `list`
* üîí `range             :` a range of values
* üîí `str               :` an immutable text sequence

## Set types: Unordered collection of **distinct hashable objects**
* ‚úèÔ∏è `set      `
* üîí `frozenset`

## Mapping types        : Maps (hashable) values to arbitrary objects

* ‚úèÔ∏è `dict              :` an unordered list of (key, object) pairs

## Other types

* `NoneType`
* `function` `module`


---

# Bool: `True False not and or` keywords

* Boolean algebra
  * `not equivalent to c++ !`
  * `and equivalent to c++ &&`
  * `or  equivalent to c++ ||`
* Equality testing
  * `== !=`
  * `< >`
  * `<= >=`
* `True` and `False` can be treated like 0 and 1 in most cases

```python
3 == 5              # False
2 == 2              # True
1 + 1 == 2          # True

True or False       # True
True or not True    # True
True and True       # True
False and True      # False

True == 1           # True
False == 0          # True
True + True + False # 2
```

---

# Bool: truth

Booleans represent **truth** values: `True` or `False`


The built-in function `bool()` gives the truth value of any object

```py
>>> a = []
>>> bool(a)
False
```

`None False 0 '' () [] set() range(0)` have a `False` truth value

The **truth** value of an object can be used in boolean operations.

```py
if a:
  ...

while a:
  ...
```

An object is considered true unless it defines a `__bool__` method:

```py
class Myclass:
  def __bool__(self):
    return True

a = A()
if a:
  print('üéâ')
```

(The `__len__` method is used as a fallback for truth testing)

---

# What `is` an object ?

## A value

```py
l1 = [2, 3]
print(l1)
```

## A type - `type()`

```py
>>> type([])
<class 'list'>
>>> type({})
<class 'dict'>
>>> type(())
<class 'tuple'>
```

## An identity - `is`

```py
>>> l1 = []
>>> l2 = []
>>> l3 = l1 # aliasing l1
>>> id(l1)
140247995728960
>>> id(l2)
140247995729024

>>> l1 == l2 # compares equality
True
>>> l1 is l2 # compares identity
False
>>> l3 is l1
True
```

---

# `None`, `is` keywords

* `None` is a special constant representing the absence of a value
* a function without a `return` statement returns a `None` object
* the type of `None` is `NoneType`

Its **truth** value is False

```py
>>> a = None
>>> print(bool(a))
False
```

This is very useful to implement optionals

```py
# python 3.10 syntax otherwise, use typing.Optional
def getFile(path: str) -> File | None:
  ...
  if noSpaceOnDevice:
    return None
  else:
    return file

f = getFile()
if f:
  f.write(...)
```

‚ùå You should **NEVER** use `==` to compare against `None` and always use `is`

```python
class Foo:
    def __eq__(self, other):
        return True

foo = Foo()
print(foo == None) # True
print(foo is None) # False
```

---

# Numeric types

## Standard numeric types: `int`, `float` and `complex`

* `int` have **unlimited precision**
* `float` usually correspond to a `C` `double` (check `sys.float_info`)
* `complex` number's real and imaginary parts are `float` numbers (`z.real` and `z.imag`)

:arrow_right: other types can be found in the standard library (`fractions`, `decimal`...)

## Operations

```python
x + y           # sum of x and y
x - y           # difference of x and y
x * y           # product of x and y
x / y           # quotient of x and y
x // y          # floored quotient of x and y
x % y           # remainder of x / y
-x              # x negated
+x              # x unchanged
abs(x)          # absolute value or magnitude of x
int(x)          # x converted to integer
float(x)        # x converted to floating point
complex(re, im) # a complex number
c.conjugate()   # conjugate of the complex number c
divmod(x, y)    # the pair (x // y, x % y)
pow(x, y)       # x to the power y
x ** y          # x to the power y

# for int and float numbers:

math.trunc(x)   # x truncated to Integer
round(x[, n])   # x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0.
math.floor(x)   # the greatest Integer <= x
math.ceil(x)    # the least Integer >= x
```

---

# Specific operations on `int` and `float` numbers

## Bitwise operations for `int`

```python
x | y  # bitwise or of x and y
x ^ y  # bitwise exclusive or of x and y
x & y  # bitwise and of x and y
x << n # x shifted left by n bits
x >> n # x shifted right by n bits
~x     # the bits of x inverted
```

## Other methods for `int`

```python
n = -37
bin(n) # '-0b100101'
n.bit_length() # 6
```
```python
(1024).to_bytes(2, byteorder='big')                # b'\x04\x00'
(1024).to_bytes(10, byteorder='big')               # b'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'
(-1024).to_bytes(10, byteorder='big', signed=True) # b'\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00'
```
```python
int.from_bytes(b'\x00\x10', byteorder='big')               # 16
int.from_bytes(b'\x00\x10', byteorder='little')            # 4096
int.from_bytes(b'\xfc\x00', byteorder='big', signed=True)  # -1024
int.from_bytes(b'\xfc\x00', byteorder='big', signed=False) # 64512
int.from_bytes([255, 0, 0], byteorder='big')               # 16711680
```

## Other methods for `float`

```python
# hex format: [sign] ['0x'] integer ['.' fraction] ['p' exponent]

float.fromhex('0x3.a7p10') # 3740.0

float.hex(3740.0)          # '0x1.d380000000000p+11'
```

---

# Strings


## Defining a string

```py
s1 = 'single quote'
s2 = "double quote"
s3 = '''
single quote
multiline
'''
s4 = """
double quote
multiline
"""
```

## Escape sequences

```py
\\ -> \
\' -> '
\" -> "
\uxxxx -> unicode character
\n -> new line
```

## :warning: **strings are immutable in Python** :warning:

```python
a = 'Some text'
print(a[5])               # 't'
*a[5] = 'T'                # ILLEGAL
a.replace('text', 'Text') # 'Some Text'
a[:5] + 'T' + a[6:]       # 'Some Text'
```


---

# Strings

## Spliting / joining

```python
s = 'A simple string'

s.split()                 # ['A', 'simple', 'string']
' '.join(s.split())       # 'A simple string'
'   some text  '.strip()  # 'some text'
'some' + ' ' + 'text'     # 'some text'
'pipo' * 3                # 'pipopipopipo'
```

## String formatting - f-string since python 3.6 üéâ

```py
# String interpolation
>>> surname = "Junah"
>>> name = "Newsome"
>>> print(f"Hello {name} {surname}")
Hello Newsome Junah

# Format - 9 characters long 7 digits
>>> val = math.pi
>>> print(f"{val:9.3}")
  3.141593

# Cool debugging trick - print variable and name
>>> print(f"{name=}")
"name='Newsome'"
```

---

class: top

# Containers mutability

## If a `tuple` is immutable, how is this possible ?

```python
tuple0 = (1, 2)          # tuple declaration
list0 = [3, 4]           # list declaration
tuple1 = (tuple0, list0) # tuple declaration
print(tuple1)            # ((1, 2), [3, 4])

list0[0] = -1            # change list0
print(tuple1)            # ((1, 2), [-1, 4])
```

--

.hcenter[
## A container stores **references**, not objects.
]


---

# Using `list` objects

```python
l1 = []             # create an empty list

l1.append(7)        # append value
l2 = ['final', 'final2']
l1.extend(l2)       # append another list
l1.insert(1, 8)     # insert value
print(l1)           # [7, 8, 'final', 'final2']
v = l1.pop()        # get and remove last value
print(v)            # 'final2'
print(l1)           # [7, 8, 'final']
del l1[-1]          # remove last value
print(len(l1))      # 2

l2 = [1, 2, "pipo"] # create another list

l3 = l2             # l3 is another name for l2 list

print(l2)           # [1, 2, 'pipo']
print(l3)           # [1, 2, 'pipo']

l3.append('new')    # append value to l3

print(l2)           # [1, 2, 'pipo', 'new']
print(l3)           # [1, 2, 'pipo', 'new']

l4 = list(l2)       # copy a list

l4.append(3.142)    # append value to l4

print(l2)           # [1, 2, 'pipo', 'new']
print(l4)           # [1, 2, 'pipo', 'new', 3.1419999999999999]

l5 = list('abcdef') # create list from string
print(l5)           # ['a', 'b', 'c', 'd', 'e', 'f']

l6 = [l1, l2, 3]    # create a list containing lists
print(l6)           # [[7, 8], [1, 2, 'pipo', 'new'], 3]
```

---

# Using `list` elements and ranges

## Element access
```python
l = range(5)
l               # [0, 1, 2, 3, 4]
l[2]            # 2
l[-1]           # 4
l[2] = 8
l               # [0, 1, 8, 3, 4]
del l[3]
l               # [0, 1, 8, 4]
```

## Ranges (slicing)
```python
l = [0, 1, 2, 3, 4]
l[0:3]          # [0, 1, 2]
l[::2]          # [0, 2, 4]
l[-1:]          # [4]
l[-3:-1]        # [2, 3]
l[:]            # [0, 1, 2, 3, 4]
l[2:3]          # [2]
l[2:3] = ['X', 'Y']
l               # [0, 1, 'X', 'Y', 3, 4]
range(3, 6, 2)  # [3, 5]
```

## Concatenation
```python
[1, 2] + [3, 4] # [1, 2, 3, 4]
[1, 2] * 3      # [1, 2, 1, 2, 1, 2]
```

## Searching
```python
l = [0, 1, 2, 3, 4]
3 in l          # True
l.index(3)      # 3
5 in l          # False
```

---

# Iterating

## On one iterable

```python
# Iterate over values
l = list('abcde')
for v in l:
  print(v)

# Iterate over indices - try to avoid doing this
for i in range(len(l)):
  print(f"index: %d val: %r" % (i, l[i]))

# Iterate over indices and values
l = list('abcde')
for i, v in enumerate(l):
  print("index: %d val: %r" % (i, v))
```

## On multiple iterables - `zip()` built-in

```py
l1 = [1, 3]
l2 = [2, 4]
for a, b in zip(l1, l2):
  print(a, b)
# Output: 1 2
#         3 4
```

---

# `filter`, `map`, `reduce`


* `filter` keeps elements matching a criterion

```python
def f(x):
  return x % 3 == 0 or x % 5 == 0

l = range(2, 25)
filter(f, l) # [3, 5, 6, 9, 10, 12, 15, 18, 20, 21, 24]

[x for x in l if f(x)] # is equivalent
```

* `map` applies a function to each element

```python
def cube(x):
  return x*x*x

map(cube, range(1, 11)) # [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]

[cube(x) for x in l] # is equivalent

# Example with two arguments
def add(x, y):
  return x+y

seq = range(8)
map(add, seq, seq) # [0, 2, 4, 6, 8, 10, 12, 14]
```

* `reduce` propagates the cumulative result of a function (`fold` in caml/haskel)

```python
def add(x,y):
  return x+y

reduce(add, range(1, 11)) # 55
```

:arrow_right: used in functionnal programming

---

# List comprehensions

:arrow_right: allows to create lists in a **very concise way**

## Generic syntax

```python
[ expr [for var in expr]+ [if expr]* ]
```

## Examples

```python
# list of the first 6 even numbers
[i * 2 for i in range(6)] # [0, 2, 4, 6, 8, 10]

# combine elements of two lists if they differ
[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] # [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

# is equivalent to
final = []
for x in [1,2,3]:
  for y in [3,1,4]:
    if x != y:
      final.append((x, y))
final                                                # [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```


---

# Using `dict` objects

* A `dict` stores unordered (`key`, `value`) pairs
* Keys are unique and not ordered

```python
# create an empty dict
d = {}
d = dict()

# initialize a dict
other_dict = {'first': 8, 'other': ['a', 'pair'], 'toto': {'pipo': 42}}
other_dict = dict(first = 8, other = ['a', 'pair'], toto = dict(pipo =  42))

d['key0'] = 'text0'
d['key1'] = 'text1'
d['key2'] = 'text2'
print(d)                 # {'key2': 'text2', 'key0': 'text0', 'key1': 'text1'}

d['key0'] = 'other_text' # replace value for key 'key0'
del d['key1']            # remove key and value for key 'key1'
print(d)                 # {'key2': 'text2', 'key0': 'other_text'}

'key1' in d              # False
'key2' in d              # True

d.keys()                 # ['key2', 'key0']
d.values()               # ['text2', 'other_text']

for k in d:              # iterate over a dict
  print(k)
# Output:
# key2
# key0
```

---

# Using `set` objects

* A `set` stores unordered and unique objects

```python
# create an empty set
s = set()

# initialize a set
s1 = set(['Beta', 'Gamma', 'Alpha', 'Delta', 'Gamma', 'Beta'])
s2 = set(['Beta', 'Alpha', 'Epsilon', 'Omega', 'Psi'])

s1                          # set(['Alpha', 'Beta', 'Gamma', 'Delta'])
s2                          # set(['Alpha', 'Beta', 'Omega', 'Psi', 'Epsilon'])

# test if a value is in a set
'Psi' in s2                 # True

# remove a value
s2.remove('Psi')

'Psi' in s2                 # False
s2                          # set(['Alpha', 'Beta', 'Omega', 'Epsilon'])
```

## Usual `set` operations
```python
s1 = set(['Alpha', 'Beta', 'Gamma', 'Delta'])
s2 = set(['Alpha', 'Beta', 'Omega', 'Epsilon'])

s1.union(s2)                #  set(['Epsilon', 'Beta', 'Delta', 'Alpha', 'Omega', 'Gamma'])
s1 | s2                     #  set(['Epsilon', 'Beta', 'Delta', 'Alpha', 'Omega', 'Gamma'])

s1.intersection(s2)         # set(['Alpha', 'Beta'])
s1 & s2                     # set(['Alpha', 'Beta'])

s1.difference(s2)           # set(['Gamma', 'Delta'])
s1 - s2                     # set(['Gamma', 'Delta'])

s1.symmetric_difference(s2) # set(['Epsilon', 'Delta', 'Omega', 'Gamma'])
s1 ^ s2                     # set(['Epsilon', 'Delta', 'Omega', 'Gamma'])
```
---

class: top

# File IO

## .hcenter[`[data.txt]`]
```text
1.0 2.1 3.0 4.9 5.9
9.0 8.2 5.7 6.2 7.1
2.2 3.6 4.4
```

## Read

```python
f = open('data.txt', 'r')          # open the file for reading
lines = f.readlines()              # read the lines: list[str]
for line in lines:                 # print the line
  print(line)
```

## Write

```python
f = open('data.txt', 'w')          # open the file for writing
f.write("some text")
```

--

## Oops, I forgot to `close()` the file üò´

--

## üéâ Context managers: `with`

```python
with open('data.txt') as f:        # the file is automatically closed once the context ends
  lines = f.readlines()            # read the lines: list[str]

for line in lines:                 # print the line
  print(line)
```

---

# Python typing

* javascript -> typescript

```py
def f(a: int, b: list[int]) -> dict[int, int]:
  pass
```

* `mypy`: optional static type checker
* you can have the **safety of a static type language**
* `typing`: the built-in module where most of python typing lived
  * now features a lot of experimental typing features (generics, ...)

‚û°Ô∏è This help your lsp (language server protocol) help you (DEMO)

## What should be type-hinted ? Interfaces

‚úÖ function arguments and return values

‚úÖ class attributes

‚ùå usually not necessary to annotate variables

```
a: list = []
a = []
```

‚ùå `self: Self` not necessary...

---

# Bonus: `pip` and `venv`

.hcenter[
![](images/present.png)
]

---

# Bonus: `pickle` and `json`

:arrow_right: allows to serialize / deserialize data

## Write
```python
import pickle

data1 = {
  'a': [1, 2.0, 3, 4+6j],
  'b': ('string', u'Unicode string'),
  'c': None
}
with open('data.pkl', 'wb') as output:
  pickle.dump(data1, output)
```

## Read

```python
import pprint, pickle

pkl_file = open('data.pkl', 'rb')
with open('data.pkl', 'wb') as output:
  data1 = pickle.load(pkl_file)
pprint.pprint(data1)
# Output:
# {'a': [1, 2.0, 3, (4+6j)], 'b': ('string', u'Unicode string'), 'c': None}
```

üéâ The `json` module has exactly the same syntax: `dump` and `load` 

‚û°Ô∏è But the data must be json serializable

    </textarea>

    <script src="core/javascript/remark.js"></script>
    <script src="core/javascript/katex.min.js"></script>
    <script src="core/javascript/auto-render.min.js"></script>
    <script src="core/javascript/emojify.js"></script>
    <script src="core/javascript/mermaid.js"></script>
    <script src="core/javascript/term.js"></script>
    <script src="core/javascript/jquery-2.1.1.min.js"></script>
    <script src="core/javascript/extend-jquery.js"></script>
    <script src="core/javascript/cinescript.js"></script>
    <script src="core/javascript/gitgraph.js"></script>
    <script>

    // === Remark.js initialization ===
    var slideshow = remark.create({
      highlightStyle: 'monokai',
      countIncrementalSlides: false,
      highlightLines: true
    });

    // === Mermaid.js initialization ===
    mermaid.initialize({
      startOnLoad: false,
      cloneCssStyles: false,
      flowchart:{
        height: 50
      },
      sequenceDiagram:{
        width: 110,
        height: 30
      }
    });

    function initMermaid(s) {
      var diagrams = document.querySelectorAll('.mermaid');
      var i;
      for(i=0;i<diagrams.length;i++){
        if(diagrams[i].offsetWidth>0){
          mermaid.init(undefined, diagrams[i]);
        }
      }
    }

    slideshow.on('afterShowSlide', initMermaid);
    initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);

    
    // === Emojify.js initialization ===
    emojify.run();

    // === Cinescript initialization ===
    $(document).ready(init_cinescripts);

    renderMathInElement(document.body,{delimiters: [{left: "$$", right: "$$", display: true}, {left: "\\(", right: "\\)", display: false}], ignoredTags: [] });

    </script>
  </body>
</html>

