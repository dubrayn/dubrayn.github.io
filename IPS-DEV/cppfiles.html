<!DOCTYPE html>
<html>
  <head>
    <title>IPS-DEV</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="core/fonts/mono.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/animate.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/cinescript.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/style_core.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/mermaid.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/gitgraph.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/style_ensiie.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/katex.css"> 
  </head>
  <body>
    <textarea id="source" readonly>

layout: true
class: animated fadeIn middle numbers

.footnote[
`IPS-DEV` - N. Dubray - ENSIIE - 2024 - [:book:](../index.html)
]

---

# Zen of `C++`

.hcenter.shadow.w60[![](images/zen.jpg)]

.hcenter[How to organize your `C++` mess...]

---

# `C++` Hello world !

:arrow_right: `examples/helloworld_cpp`

.row[
.column.w48[
## .hcenter[`myclass.h`]
```C++
#ifndef MYCLASS_H
#define MYCLASS_H

class MyClass
{
  public:
  MyClass(int);    // constructor
  int myFunc(int); // method
  int a;           // member
};
#endif // MYCLASS_H
```
]

.column.w48[
## .hcenter[`myclass.cpp`]
```C++
#include "myclass.h"

MyClass::MyClass(int _a) : a(_a)
{
// possible other ways: "a = int(_a);" or "a = _a;"
}

int MyClass::myFunc(int b)
{
  return a + b; // "a" is the same as "this->a"
}
```
]
]

.row[
.column.w48[
## .hcenter[`main.cpp`]

```C++
#include "myclass.h"

#include <iostream>

int main(int charc, char** argv)
{
  MyClass myClass(2);

  std::cout << "Result: " << myClass.myFunc(3);
  std::cout << std::endl;

  return 0;
}
```
]

.column.w48[
## .hcenter[Build & launch `main`]
```sh
$ g++ -Wall -c myclass.cpp -o myclass.o
$ g++ -Wall -c main.cpp -o main.o
$ g++ main.o myclass.o -o main
./main
Result: 5
```

]
]

---

# Compiler / linker

.mermaid[
    graph LR
              source["source files<br>.cpp / .cxx"] -- compilation --> objects[object files<br>.o]
              objects -- link --> executable[executable file]
]

:arrow_right: Separate invocations of `g++`

```shell
* compilation
$ g++ -Wall -c myclass.cpp -o myclass.o

* compilation
$ g++ -Wall -c main.cpp -o main.o

* link
$ g++ main.o myclass.o -o main
```

:arrow_right: 2-in-1 command :warning:
```shell
* compilation + link
$ g++ -Wall -c myclass.cpp main.cpp -o main
```

---

# `g++` main options

.row[.column.w48[
## Compiler mode

* `-c` compile, do not link
* `-Wall` display all warnings
* `-Werror` treat warnings as errors (stop)
* `-Ox` optimization level (x = 0..4)
* `-g` generate debug symbols
* `-I` specify additional path for include files
* `-std=c++11` specify the C++ version
]
.column.w48[
## Linker mode
* `-L` specify additional path for library files
* `-ltoto` use library file `libtoto.so`
* `-o result` specify output file `result`
]
]

## Example
```shell
$ g++ -std=c++11 -g -O3 -I../inc -Wall -Werror -L~/.local/lib -L../lib -lsuper -larma sol.cpp main.cpp -o go
```

1. which file(s) will be generated ?
2. what can be an issue when debugging ?
3. what can be an issue when developping ?

---

# Where does g++ look ?

## For include files `-I`

```sh
$ gcc -I/tmp/ -c valgrind.cpp -v

#include "..." search starts here:
#include <...> search starts here:
 /tmp
 /usr/lib/gcc/x86_64-redhat-linux/11/../../../../include/c++/11
 /usr/lib/gcc/x86_64-redhat-linux/11/../../../../include/c++/11/x86_64-redhat-linux
 /usr/lib/gcc/x86_64-redhat-linux/11/../../../../include/c++/11/backward
 /usr/lib/gcc/x86_64-redhat-linux/11/include
 /usr/local/include
 /usr/include
End of search list.
```

## For libraries `-L`

```
$ gcc -L/tmp -v valgrind.o 2>&1 | grep "\-L"

/usr/libexec/gcc/x86_64-redhat-linux/11/collect2 -plugin /usr/libexec/gcc/x86_64-redhat-linux/11/liblto_plugin.so -plugin-opt=/usr/libexec/gcc/x86_64-redhat-linux/11/lto-wrapper -plugin-opt=-fresolution=/tmp/cc1M7eKZ.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/gcc/x86_64-redhat-linux/11/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/11/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/11/crtbegin.o -L/tmp -L/usr/lib/gcc/x86_64-redhat-linux/11 -L/usr/lib/gcc/x86_64-redhat-linux/11/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/11/../../.. valgrind.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-redhat-linux/11/crtend.o /usr/lib/gcc/x86_64-redhat-linux/11/../../../../lib64/crtn.o
```

---

# What are object files ?

## `nm`

> List symbols from object files

```c
double x = 0;

double f(int a) {
  return 0.;
}
```

⚙️ Compile to object with gcc

```
> gcc -c a.c
> nm a.o
0000000000000000 B x
0000000000000000 T f
```

⚠️ c++ name mangling

```
> gcc -c a.cpp
> nm a.o
0000000000000000 B x
0000000000000000 T _Z1fi
```

## dynamic library symbols

```
> nm -D /lib64/libm.so.6 | grep cos
```

* more detailed tool: `objdump`

---

# How does library resolution work ?

## ldd

> prints the shared objects required by each program

```sh
❯ ldd main
	linux-vdso.so.1 (0x00007ffd109a5000)
	libarmadillo.so.12 => /lib64/libarmadillo.so.12 (0x00007f72dcfdd000)
	libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007f72dcc00000)
	libm.so.6 => /lib64/libm.so.6 (0x00007f72dcf02000)
	libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007f72dcee8000)
	libc.so.6 => /lib64/libc.so.6 (0x00007f72dc800000)
	libopenblaso.so.0 => /lib64/libopenblaso.so.0 (0x00007f72d9e00000)
	liblapack.so.3 => /lib64/liblapack.so.3 (0x00007f72d9600000)
	libarpack.so.2 => /lib64/libarpack.so.2 (0x00007f72dce9a000)
	libsuperlu.so.6 => /lib64/libsuperlu.so.6 (0x00007f72dcb8a000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f72dd009000)
	libgfortran.so.5 => /lib64/libgfortran.so.5 (0x00007f72d9200000)
	libgomp.so.1 => /lib64/libgomp.so.1 (0x00007f72dce54000)
	libblas.so.3 => /lib64/libblas.so.3 (0x00007f72dcb00000)
	libflexiblas.so.3 => /lib64/libflexiblas.so.3 (0x00007f72d8e00000)
	libquadmath.so.0 => /lib64/libquadmath.so.0 (0x00007f72dcab6000)
	libmetis.so.0 => /lib64/libmetis.so.0 (0x00007f72dca4c000)
	libpcre2-posix.so.3 => /lib64/libpcre2-posix.so.3 (0x00007f72dce4d000)
	libpcre2-8.so.0 => /lib64/libpcre2-8.so.0 (0x00007f72dc764000)
```

---

# General `C++` advices

:bulb: Beginner-friendly advices for "simple" scientific code

## Do not use `new` and `delete`

.row[
.column.w48[
```C++
MyClass *myClass = new MyClass(2);
std::cout << "Result: " << myClass->myFunc(3);
delete(myClass);
```
]
.column.w5.middle[
:arrow_right:
]
.column.w48[
```C++
MyClass myClass(2);
std::cout << "Result: " << myClass.myFunc(3);
```
]
]

## Do not use `char*`

.row[
.column.w48[
```C++
char mesg[] = "my name is Noël";
std::cout << mesg << "\n";
```
]
.column.w5.middle[
:arrow_right:
]
.column.w48[
```C++
std::string mesg = "my name is Noël";
std::cout << mesg << "\n";
```
]
]

## Do not use `this->`

.row[
.column.w48[
```C++
class Pipo
{
  public:
  Pipo() { std::cout << this->a << std::endl; }
  int a = 5;
};
```
]
.column.w5.middle[
:arrow_right:
]
.column.w48[
```C++
class Pipo
{
  public:
  Pipo() { std::cout << a << std::endl; }
  int a = 5;
};
```
]
]

## Use brace initializers

.row[
.column.w48[
```C++
  std::vector<std::string> toto;
  toto.push_back("tutu");
  toto.push_back("titi");
```
]
.column.w5.middle[
:arrow_right:
]
.column.w48[
```C++
std::list<std::string> toto = {
  "tutu", 
  "titi"
};
```
]
]

---

class: top

# General `C++` advices - for loops

```C++
const std::list<std::tuple<std::string, std::string>> countryCodes {
    { "Switzerland", "41"},
    { "Italy", "39"},
    { "France", "33"},
    { "UK", "44"},
};

for (int i=0; i < countryCodes.size(); i++)
    std::cout << countryCodes[i].first << " " << countryCodes[i].second << "\n";
```

--

## Use range-based for loops `c++11`

```C++
const std::list<std::tuple<std::string, std::string>> countryCodes {
    { "Switzerland", "41"},
    { "Italy", "39"},
    { "France", "33"},
    { "UK", "44"},
};

*for (auto& elem: countryCodes)
    std::cout << elem.first << " " << elem.second << "\n";
```

--

## ... and structured bindings `c++17`

```C++
const std::list<std::tuple<std::string, std::string>> countryCodes {
    { "Switzerland", "41"},
    { "Italy", "39"},
    { "France", "33"},
    { "UK", "44"},
};

*for (auto& [country, code]: countryCodes)
    std::cout << country << " " << code << "\n";
```

---

class: top

# General `C++` advices - nesting


## Linux Kernel coding standards

.row[
.col.w10[
![](images/linus.jpg)
]
.col.w90[
> "Now, some people will claim that having **8-character indentations** makes the code move too far to the right, and makes it hard to read on a 80-character terminal screen. 
> The answer to that is that if you need more than **3 levels of indentation**, you're screwed anyway, and should fix your program."
]
]

--

## Guard clauses: return as early as possible

.row[
.column.w48[
```cpp
void f(int status)
{
  if (status == OK)
  {
    dosomething();
  }
}
```
]

.column.w48[
```cpp
void f(int status)
{
  if (status != OK) return;

  dosomething();
}
```
]
]

* Removes 1 level of indentation
* All edge cases are dealt with at the beginning

--

## Extract complex logic in another function

---

class: top

# General `C++` advices - naming things

## Never abbreviate

.row[
.column.w35[
```cpp
double reScore(Movie m1, Movie m2) {

  const GW = 0.4;
  const YW = 0.1;
  const DW = 0.2;
  const WW = 0.3;

  double s = 0;
  if (m1.gen == m2.gen) s += GW;
  if (m1.yr  == m2.yr ) s += YW;
  if (m1.dir == m2.dir) s += DW;

  for (auto w: m1.ws) {
    if (m2.ws.find(w) != -1) {
      s += WW;
      break;
    }
  }

  return s;
}
```
]
.column.w65[
```cpp
double movieRelationScore(Movie movie1, Movie movie2) {

  const GENRE_WEIGHT    = 0.4;
  const YEAR_WEIGHT     = 0.1;
  const DIRECTOR_WEIGHT = 0.2;
  const WRITER_WEIGHT   = 0.3;

  double score = 0;
  if (movie1.genre    == movie2.genre   ) score += GENRE_WEIGHT;
  if (movie1.year     == movie2.year    ) score += YEAR_WEIGHT;
  if (movie1.director == movie2.director) score += DATE_WEIGHT;

  for (auto writer: m1.writers) {
    if (movie2.writers.find(writer) != -1) {
      score += WRITER_WEIGHT;
      break;
    }
  }

  return score;
}
```
]
]

--

## Make renaming easy and rename often

* vim: `vim.lsp.buf.rename()`
* vscode: `F2`

---

class:top

# `C++` files: organizing, naming, testing

## 1 class = 1 interface **`.h`** + 1 implementation **`.cpp`**

* Class `Solver`: `solver.cpp` and `solver.h`
* Class `Boat`: `boat.cpp` and `boat.h`

--

## 1 namespace = 1 interface **`.h`** + 1 implementation **`.cpp`**

* Namespace `Tools` in files `tools.cpp` and `tools.h`
* Namespace `Global` in files `global.cpp` and `global.h`

--

## 1 static library **`.a`** [+ 1 main file]

* All classes and namespaces in `mylib.a`
* If needed, main program in `main.cpp` (no `main.h` file)

--

## 1 library = 1 directory

* For multi-libraries projects, separate the libraries

--

## 1 static library = 1 set of bindings

* Generate bindings for some classes (maybe not all of them)
* Generate bindings for some methods (maybe not all of them)

--

## 1 function = 1 unit test

* Write a unit test for every single function/method

---


# `C++` headers: main rules

.row[
.column.w55.middle[
## Rules

* same methods in `%.h` and `%.cpp`
* one class per `%.h` file
* `%.h` **first included file** in `%.cpp`
* no `everything.h` header
* use `#define` guards
* separate public and private headers
* default values belong to `%.h`
* **no forward-declarations** (if possible)
]
.column.w40[
## .hcenter[`myclass.h`]
```C++
#ifndef MYCLASS_H
#define MYCLASS_H

#include <iostream>

class MyClass
{
  public:
  MyClass(int, int);

  int myFunc(double e = -1.0);
};

#endif // MYCLASS_H
```

## .hcenter[`myclass.cpp`]
```C++
#include "myclass.h"

MyClass::MyClass(int a, int b)
{
  ...
}

int MyClass::myFunc(double e)
{
  ...
}
```
]
]

---

# `C++` headers: main rules

.row[
.column.w55.middle[
## Rules

* same methods in `%.h` and `%.cpp` :arrow_left:
* one class per `%.h` file
* `%.h` **first included file** in `%.cpp`
* no `everything.h` header
* use `#define` guards
* separate public and private headers
* default values belong to `%.h`
* **no forward-declarations** (if possible)
]
.column.w40[
## .hcenter[`myclass.h`]
```C++
#ifndef MYCLASS_H
#define MYCLASS_H

#include <iostream>

class MyClass
{
  public:
* MyClass(int, int);

* int myFunc(double e = -1.0);
};

#endif // MYCLASS_H
```

## .hcenter[`myclass.cpp`]
```C++
#include "myclass.h"

*MyClass::MyClass(int a, int b)
{
  ...
}

*int MyClass::myFunc(double e)
{
  ...
}
```
]
]

---

# `C++` headers: main rules

.row[
.column.w55.middle[
## Rules

* same methods in `%.h` and `%.cpp`
* one class per `%.h` file :arrow_left:
* `%.h` **first included file** in `%.cpp`
* no `everything.h` header
* use `#define` guards
* separate public and private headers
* default values belong to `%.h`
* **no forward-declarations** (if possible)
]
.column.w40[
## .hcenter[`myclass.h`]
```C++
#ifndef MYCLASS_H
#define MYCLASS_H

#include <iostream>

*class MyClass
{
  public:
  MyClass(int, int);

  int myFunc(double e = -1.0);
};

#endif // MYCLASS_H
```

## .hcenter[`myclass.cpp`]
```C++
#include "myclass.h"

MyClass::MyClass(int a, int b)
{
  ...
}

int MyClass::myFunc(double e)
{
  ...
}
```
]
]

---

# `C++` headers: main rules

.row[
.column.w55.middle[
## Rules

* same methods in `%.h` and `%.cpp`
* one class per `%.h` file
* `%.h` **first included file** in `%.cpp` :arrow_left:
* no `everything.h` header
* use `#define` guards
* separate public and private headers
* default values belong to `%.h`
* **no forward-declarations** (if possible)
]
.column.w40[
## .hcenter[`myclass.h`]
```C++
#ifndef MYCLASS_H
#define MYCLASS_H

#include <iostream>

class MyClass
{
  public:
  MyClass(int, int);

  int myFunc(double e = -1.0);
};

#endif // MYCLASS_H
```

## .hcenter[`myclass.cpp`]
```C++
*#include "myclass.h"

MyClass::MyClass(int a, int b)
{
  ...
}

int MyClass::myFunc(double e)
{
  ...
}
```
]
]

---

# `C++` headers: main rules

.row[
.column.w55.middle[
## Rules

* same methods in `%.h` and `%.cpp`
* one class per `%.h` file
* `%.h` **first included file** in `%.cpp`
* no `everything.h` header :arrow_left:
* use `#define` guards
* separate public and private headers
* default values belong to `%.h`
* **no forward-declarations** (if possible)
]
.column.w40[
## .hcenter[`myclass.h`]
```C++
#ifndef MYCLASS_H
#define MYCLASS_H

#include <iostream>

class MyClass
{
  public:
  MyClass(int, int);

  int myFunc(double e = -1.0);
};

#endif // MYCLASS_H
```

## .hcenter[`myclass.cpp`]
```C++
#include "myclass.h"

MyClass::MyClass(int a, int b)
{
  ...
}

int MyClass::myFunc(double e)
{
  ...
}
```
]
]

---

# `C++` headers: main rules

.row[
.column.w55.middle[
## Rules

* same methods in `%.h` and `%.cpp`
* one class per `%.h` file
* `%.h` **first included file** in `%.cpp`
* no `everything.h` header
* use `#define` guards :arrow_left:
* separate public and private headers
* default values belong to `%.h`
* **no forward-declarations** (if possible)
]
.column.w40[
## .hcenter[`myclass.h`]
```C++
*#ifndef MYCLASS_H
*#define MYCLASS_H

#include <iostream>

class MyClass
{
  public:
  MyClass(int, int);

  int myFunc(double e = -1.0);
};

*#endif // MYCLASS_H
```

## .hcenter[`myclass.cpp`]
```C++
#include "myclass.h"

MyClass::MyClass(int a, int b)
{
  ...
}

int MyClass::myFunc(double e)
{
  ...
}
```
]
]

---

# `C++` headers: main rules

.row[
.column.w55.middle[
## Rules

* same methods in `%.h` and `%.cpp`
* one class per `%.h` file
* `%.h` **first included file** in `%.cpp`
* no `everything.h` header
* use `#define` guards
* separate public and private headers :arrow_left:
* default values belong to `%.h`
* **no forward-declarations** (if possible)
]
.column.w40[
## .hcenter[`myclass.h`]
```C++
#ifndef MYCLASS_H
#define MYCLASS_H

#include <iostream>

class MyClass
{
  public:
  MyClass(int, int);

  int myFunc(double e = -1.0);
};

#endif // MYCLASS_H
```

## .hcenter[`myclass.cpp`]
```C++
#include "myclass.h"

MyClass::MyClass(int a, int b)
{
  ...
}

int MyClass::myFunc(double e)
{
  ...
}
```
]
]

---

# `C++` headers: main rules

.row[
.column.w55.middle[
## Rules

* same methods in `%.h` and `%.cpp`
* one class per `%.h` file
* `%.h` **first included file** in `%.cpp`
* no `everything.h` header
* use `#define` guards
* separate public and private headers
* default values belong to `%.h` :arrow_left:
* **no forward-declarations** (if possible)
]
.column.w40[
## .hcenter[`myclass.h`]
```C++
#ifndef MYCLASS_H
#define MYCLASS_H

#include <iostream>

class MyClass
{
  public:
  MyClass(int, int);

* int myFunc(double e = -1.0);
};

#endif // MYCLASS_H
```

## .hcenter[`myclass.cpp`]
```C++
#include "myclass.h"

MyClass::MyClass(int a, int b)
{
  ...
}

int MyClass::myFunc(double e)
{
  ...
}
```
]
]

---

# `C++` headers: main rules

.row[
.column.w55.middle[
## Rules

* same methods in `%.h` and `%.cpp`
* one class per `%.h` file
* `%.h` **first included file** in `%.cpp`
* no `everything.h` header
* use `#define` guards
* separate public and private headers
* default values belong to `%.h`
* **no forward-declarations** (if possible) :arrow_left:
]
.column.w40[
## .hcenter[`myclass.h`]
```C++
#ifndef MYCLASS_H
#define MYCLASS_H

#include <iostream>

class MyClass
{
  public:
  MyClass(int, int);

  int myFunc(double e = -1.0);
};

#endif // MYCLASS_H
```

## .hcenter[`myclass.cpp`]
```C++
#include "myclass.h"

MyClass::MyClass(int a, int b)
{
  ...
}

int MyClass::myFunc(double e)
{
  ...
}
```
]
]

---

# Conclusions

* **always** read the output from the compiler, **even warnings**,
* use `-Wall` and `-Werror`,
* read and understand some existing, well-written `C++` code,
* do some coding exercices,
* know the main differences (`C++03`, `C++11`, `C++14`, `C++17`, `C++20`, etc...),
.hcenter[
## Yes, `C++` code can be beautiful :heart:
]

---

class: top

# A `C++` joke

* yes, some `C++` jokes exist,
* source: [https://www.learncpp.com](https://www.learncpp.com) (nice site to learn how to write some nice `C++` code).

.hcenter.shadow.w60[![](images/microphone.png)]

## .hcenter[What’s the best naming prefix for a global variable ?]

--

## .hcenter[Answer: `//`]

    </textarea>

    <script src="core/javascript/remark.js"></script>
    <script src="core/javascript/katex.min.js"></script>
    <script src="core/javascript/auto-render.min.js"></script>
    <script src="core/javascript/emojify.js"></script>
    <script src="core/javascript/mermaid.js"></script>
    <script src="core/javascript/term.js"></script>
    <script src="core/javascript/jquery-2.1.1.min.js"></script>
    <script src="core/javascript/extend-jquery.js"></script>
    <script src="core/javascript/cinescript.js"></script>
    <script src="core/javascript/gitgraph.js"></script>
    <script>

    // === Remark.js initialization ===
    var slideshow = remark.create({
      highlightStyle: 'monokai',
      countIncrementalSlides: false,
      highlightLines: true
    });

    // === Mermaid.js initialization ===
    mermaid.initialize({
      startOnLoad: false,
      cloneCssStyles: false,
      flowchart:{
        height: 50
      },
      sequenceDiagram:{
        width: 110,
        height: 30
      }
    });

    function initMermaid(s) {
      var diagrams = document.querySelectorAll('.mermaid');
      var i;
      for(i=0;i<diagrams.length;i++){
        if(diagrams[i].offsetWidth>0){
          mermaid.init(undefined, diagrams[i]);
        }
      }
    }

    slideshow.on('afterShowSlide', initMermaid);
    initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);

    
    // === Emojify.js initialization ===
    emojify.run();

    // === Cinescript initialization ===
    $(document).ready(init_cinescripts);

    renderMathInElement(document.body,{delimiters: [{left: "$$", right: "$$", display: true}, {left: "\\(", right: "\\)", display: false}], ignoredTags: [] });

    </script>
  </body>
</html>

